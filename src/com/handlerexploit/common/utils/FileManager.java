/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.common.utils;

import static com.handlerexploit.internal.apache.FileUtils.deleteQuietly;
import static com.handlerexploit.internal.apache.FileUtils.moveFile;
import static com.handlerexploit.internal.apache.FileUtils.openOutputStream;
import static com.handlerexploit.internal.apache.IOUtils.closeQuietly;
import static com.handlerexploit.internal.apache.IOUtils.copy;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import android.content.Context;
import android.os.Environment;

import com.handlerexploit.common.Configuration;
import com.handlerexploit.internal.apache.CountingOutputStream;
import com.handlerexploit.internal.apache.DigestUtils;

public class FileManager {
    
    private static final int FILE_EXPIRATION_MILLIS = Configuration.getFileExpirationInMillis();

    private static FileManager sInstance = new FileManager();
    
    private Map<File, Lock> mDestinationLockMap = new HashMap<File, Lock>();
    
    private FileManager() {
        super();
    }
    
    public static FileManager getInstance() {
        return sInstance;
    }

    /**
     * Copies bytes from the URL source to a file destination if the file is
     * found to be in the 'expired' state.
     */
    public void copyURLToFileOnExpiration(String source, File destination) {
        copyURLToFileOnExpiration(source, destination, null);
    }
    
    /**
     * Copies bytes from the URL source to a file destination if the file is
     * found to be in the 'expired' state. Provides listener for download
     * progress.
     */
    public void copyURLToFileOnExpiration(String source, File destination, final OnProgressUpdatedListener listener) {
        
        Lock destinationLock;
        synchronized (mDestinationLockMap) {
            destinationLock = mDestinationLockMap.get(destination);
            if (destinationLock == null) {
                destinationLock = new ReentrantLock();
                mDestinationLockMap.put(destination, destinationLock);
            }
        }
        
        try {
            destinationLock.lock();
            if (!isExpired(destination)) {
                return;
            }
            
            File tempFile = new File(destination.getAbsolutePath() + ".tmp");
            try {
                deleteQuietly(tempFile);
                
                InputStream input = null;
                OutputStream output = null;
                try {
                    final URLConnection urlConnection = new URL(source).openConnection();

                    input = urlConnection.getInputStream();
                    output = new CountingOutputStream(openOutputStream(tempFile)) {
                        
                        int contentLength = urlConnection.getContentLength();
                        int currentProgress = 0;
                        
                        @Override
                        protected void afterWrite(int n) throws IOException {
                            super.afterWrite(n);

                            int progress = (int) (getCount() * 100 / contentLength);
                            if (progress > currentProgress) {
                                currentProgress = progress;
                                if (listener != null) {
                                    listener.onProgressUpdate(progress);
                                }
                            }
                        }
                    };
                    
                    copy(input, output);
                } finally {
                    closeQuietly(input);
                    closeQuietly(output);
                }
            } catch (IOException e) {
                deleteQuietly(tempFile);
            } finally {
                if (tempFile.exists()) {
                    deleteQuietly(destination);
                    try {
                        moveFile(tempFile, destination);
                    } catch (IOException e) {
                        deleteQuietly(tempFile);
                        deleteQuietly(destination);
                    }
                }
            }
        } finally {
            destinationLock.unlock();
        }
    }
    
    /**
     * Internal implementation that determines the business logic of file
     * expiration.
     */
    private boolean isExpired(File file) {
         return !file.exists() || System.currentTimeMillis() > file.lastModified() + FILE_EXPIRATION_MILLIS;
    }
    
    public static File getFileDestination(Context context, String source) {
        File destination;
        switch (Configuration.getImageDownloadLocation()) {
        case INTERNAL:
            destination = getInternalFileDestination(context, source);
            break;
        case EXTERNAL:
            destination = getExternalFileDestination(context, source);
            break;
        default:
            throw new RuntimeException();
        }
        return destination;
    }
    
    private static File getInternalFileDestination(Context context, String source) {
        return new File(Environment.getDataDirectory().getAbsolutePath() + "/data/" + context.getPackageName() + "/cache/", DigestUtils.sha256Hex(source));
    }
    
    private static File getExternalFileDestination(Context context, String source) {
        return new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + context.getPackageName() + "/cache/", DigestUtils.sha256Hex(source));
    }
    
    public static interface OnProgressUpdatedListener {
        public void onProgressUpdate(int progress);
    }
}