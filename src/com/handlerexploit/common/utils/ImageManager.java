/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.common.utils;

import java.io.File;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Handler;
import android.os.Looper;

import com.handlerexploit.common.Configuration;
import com.handlerexploit.internal.android.LruCache;

public class ImageManager {

    private static ImageManager sInstance = new ImageManager();
    
    private Handler mHandler = new Handler();
    
    private FileManager mFileManager = FileManager.getInstance();

    private ExecutorService mExecutorService = newConfiguredThreadPool();

    private LruCache<String, Bitmap> mBitmapLruCache = new LruCache<String, Bitmap>(Configuration.getMemoryCacheSizeInBytes()) {
        
        @Override
        public int sizeOf(String key, Bitmap value) {
            return value.getRowBytes() * value.getHeight();
        }
    };

    private ImageManager() {
        super();
    }
    
    public static ImageManager getInstance() {
        return sInstance;
    }
    
    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link String} through the {@link OnImageRecievedListener} synchronously
     * or asynchronously depending on the state of the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     */
    public void get(final Context context, final String source, final OnImageRecievedListener onImageRecievedListener) {
        if (source == null || onImageRecievedListener == null) return;
        
        /*
         * Verify that we are on the UI Thread, throw an uncaught exception if
         * we are not.
         */
        if (!Looper.getMainLooper().equals(Looper.myLooper())) {
            throw new CalledFromWrongThreadException("This must only be executed on the main UI Thread!");
        }
        
        if (mBitmapLruCache != null) {
            Bitmap bitmap = mBitmapLruCache.get(source);
            if (bitmap != null) {
                /*
                 * If we have a non-null reference associated with the given
                 * String return immediately on the UI Thread
                 */
                onImageRecievedListener.onImageReceived(source, bitmap);
                return;
            }
        }

        /*
         * If we don't have anything in the internal cache that is applicable
         * then post to the ExecutorService a request that will decode the
         * Bitmap directly from disk
         */
        mExecutorService.execute(new Runnable() {
            
            @Override
            public void run() {
                /*
                 * Check if the source file exists and is not expired. If it is
                 * either then download the file first, then proceed to decoding.
                 */
                File destination;
                switch (Configuration.getImageDownloadLocation()) {
                case INTERNAL:
                    destination = FileManager.getInternalFileDestination(context, source);
                    break;
                case EXTERNAL:
                    destination = FileManager.getExternalFileDestination(context, source);
                    break;
                default:
                    throw new RuntimeException();
                }
                
                mFileManager.copyURLToFileOnExpiration(source, destination);
                
                final Bitmap bitmap = BitmapFactory.decodeFile(destination.getAbsolutePath());
                /*
                 * Once we have a reference to the decoded Bitmap, post back to
                 * the UI Thread through the Handler to notify the
                 * OnImageRecievedListener that a Bitmap has been received
                 */
                mHandler.post(new Runnable() {
                    
                    @Override
                    public void run() {
                        /*
                         * Save a reference of the decoded Bitmap inside of the
                         * internal cache and then notify the
                         * OnImageRecievedListener of the received Bitmap
                         */
                        if (mBitmapLruCache != null && bitmap != null) {
                            mBitmapLruCache.put(source, bitmap);
                        }
                        onImageRecievedListener.onImageReceived(source, bitmap);
                    }
                });
            }
        });
    }
    
    private static ExecutorService newConfiguredThreadPool() {
        return new ThreadPoolExecutor(0, Configuration.getAsynchronousNetworkThreadCount(), 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
    }
    
    @SuppressWarnings("serial")
    private static final class CalledFromWrongThreadException extends RuntimeException {
        public CalledFromWrongThreadException(String msg) {
            super(msg);
        }
    }
    
    public static interface OnImageRecievedListener {
        public void onImageReceived(String source, Bitmap bitmap);
    }
}