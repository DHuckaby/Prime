package com.handlerexploit.prime;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.drawable.BitmapDrawable;
import android.os.Handler;
import android.os.Looper;
import android.support.v4.util.LruCache;
import android.util.DisplayMetrics;
import android.util.Log;
import com.handlerexploit.common.utils.Hashing;
import com.handlerexploit.prime.internal.BitmapMemoryLruCache;
import com.handlerexploit.prime.internal.DefaultBitmapOptionsFactory;
import com.handlerexploit.prime.internal.DefaultConnectionClient;
import com.handlerexploit.prime.internal.ExtendedRequest;
import com.handlerexploit.prime.internal.FlushedInputStream;
import com.handlerexploit.prime.internal.LowPriorityThreadFactory;
import com.handlerexploit.prime.internal.SimpleRequest;
import com.jakewharton.disklrucache.DiskLruCache;
import org.apache.commons.io.copy.IOUtils;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URL;
import java.net.URLConnection;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.RejectedExecutionHandler;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

import static com.jakewharton.disklrucache.DiskLruCache.open;

public final class Prime {

    private static final String TAG = "Prime";
    private static final Object DECODE_LOCK = new Object();

    private final URLConnectionClient mURLConnectionClient;
    private final DiskLruCache mDiskLruCache;
    private final MemoryCache mMemoryCache;
    private final BitmapOptionsFactory mBitmapOptionsFactory;
    private final boolean mDebugging;

    private final Handler mHandler = new Handler(Looper.getMainLooper());
    private final Executor mNetworkExecutorService = newLowPriorityCachedFixedThreadPool(Runtime.getRuntime().availableProcessors() * 4);
    private final Executor mDiskExecutorService = Executors.newCachedThreadPool();

    private final LruCache<String, ReentrantLock> mLockCache = new LruCache<String, ReentrantLock>(100);
    private final LruCache<String, Object> mBadUrlCache = new LruCache<String, Object>(50);

    private Prime(MemoryCache memoryCache, BitmapOptionsFactory bitmapOptionsFactory, File diskCacheDirectory, URLConnectionClient urlConnectionClient, boolean debugging, int maxDiskCacheByteSize) {
        mMemoryCache = memoryCache;
        mBitmapOptionsFactory = bitmapOptionsFactory;
        mURLConnectionClient = urlConnectionClient;
        mDebugging = debugging;

        try {
            File directory = new File(diskCacheDirectory, "/images/");
            mDiskLruCache = open(directory, 1, 1, maxDiskCacheByteSize);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    public void evictAllFromMemory() {
        mMemoryCache.evictAll();
    }

    /**
     * Return the appropriate {@link android.graphics.Bitmap} associated with the provided
     * {@link String}. This is a synchronous call, if you need to asynchronously
     * retrieve an image use
     * {@link Prime#get(String, OnImageReceivedListener)} or
     * {@link Prime#get(Request)}.
     *
     * @param source
     *            The URL of a remote image
     */
    public BitmapDrawable get(String source) {
        BitmapDrawable drawable = getBitmapFromMemory(source, null);
        if (drawable != null) {
            return drawable;
        } else {
            String key = getKey(source);
            drawable = getFromDisk(key, null);
            if (drawable == null) {
                drawable = getFromNetwork(key, source, null);
            }
            return drawable;
        }
    }

    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link OnImageReceivedListener} synchronously or asynchronously depending
     * on the state of the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     *
     * @param source
     *            The URL of a remote image
     * @param listener
     *            Listener for being notified when image is retrieved, can be
     *            null
     */
    public void get(final String source, final OnImageReceivedListener listener) {
        get(new Request() {

            @Override
            public String getSource() {
                return source;
            }

            @Override
            public void onImageReceived(String url, BitmapDrawable drawable, Source source) {
                if (listener != null) {
                    listener.onImageReceived(url, drawable, source);
                }
            }
        });
    }

    /**
     * Return the appropriate {@link Bitmap} associated with the provided
     * {@link Request} synchronously or asynchronously depending on the state of
     * the internal cache state. <br>
     * <br>
     * This must only be executed on the main UI Thread.
     */
    public void get(Request request) {
        if (request == null) {
            throw new NullPointerException("Request cannot be null");
        } else if (request instanceof ExtendedRequest) {
            get((ExtendedRequest) request);
        } else {
            get(new SimpleRequest(request));
        }
    }

    private void get(final ExtendedRequest request) {
        final String source = request.getSource();
        if (source != null) {
            final String key = getKey(source);
            BitmapDrawable drawable = getBitmapFromMemory(key, request);
            if (drawable != null) {
                request.onImageReceived(source, drawable, Source.MEMORY);
            } else {
                synchronized (mBadUrlCache) {
                    if (mBadUrlCache.get(key) != null) {
                        request.onImageRequestFailed(source);
                        return;
                    }
                }

                mDiskExecutorService.execute(new Runnable() {

                    @Override
                    public void run() {
                        if (verifySourceOverTime(source, request)) {
                            final BitmapDrawable drawable = getFromDisk(key, request);
                            if (drawable != null) {
                                mHandler.post(new Runnable() {

                                    @Override
                                    public void run() {
                                        request.onImageReceived(source, drawable, Source.DISK);
                                    }
                                });
                            } else {
                                mNetworkExecutorService.execute(new Runnable() {

                                    @Override
                                    public void run() {
                                        final BitmapDrawable drawable = getFromNetwork(key, source, request);
                                        if (drawable != null) {
                                            mHandler.post(new Runnable() {

                                                @Override
                                                public void run() {
                                                    request.onImageReceived(source, drawable, Source.NETWORK);
                                                }
                                            });
                                        } else {
                                            synchronized (mBadUrlCache) {
                                                mBadUrlCache.put(key, new Object());
                                                mHandler.post(new Runnable() {

                                                    @Override
                                                    public void run() {
                                                        request.onImageRequestFailed(source);
                                                    }
                                                });
                                            }
                                        }
                                    }
                                });
                            }
                        } else {
                            mHandler.post(new Runnable() {

                                @Override
                                public void run() {
                                    request.onImageRequestFailed(source);
                                }
                            });
                        }
                    }
                });
            }
        } else {
            request.onImageRequestFailed(null);// Source is always null here
        }
    }

    private String getMemoryCacheKey(String key, ExtendedRequest request) {
        int height = request != null ? request.getHeight() : 0;
        int width = request != null ? request.getWidth() : 0;
        return key + "|" + height + "|" + width;
    }

    private BitmapDrawable getBitmapFromMemory(String key, ExtendedRequest request) {
        return mMemoryCache.getCached(getMemoryCacheKey(key, request));
    }

    private ReentrantLock getLock(String key) {
        ReentrantLock lock;
        synchronized (mLockCache) {
            lock = mLockCache.get(key);
            if (lock == null) {
                lock = new ReentrantLock();
                mLockCache.put(key, lock);
            }
        }
        return lock;
    }

    private BitmapDrawable getFromDisk(String key, ExtendedRequest request) {
        Bitmap bitmap = null;
        ReentrantLock lock = getLock(key);
        try {
            lock.lock();
            DiskLruCache.Snapshot snapShot = null;
            InputStream inputStream = null;
            BitmapFactory.Options bitmapFactoryOptions = null;
            try {
                snapShot = mDiskLruCache.get(key);
                if (snapShot != null) {
                    inputStream = snapShot.getInputStream(0);
                    bitmapFactoryOptions = decodeSampleSize(inputStream, request);
                }
            } catch (IOException e) {
                Log.w(TAG, e);
            } finally {
                IOUtils.closeQuietly(snapShot);
                IOUtils.closeQuietly(inputStream);
            }

            if (bitmapFactoryOptions != null) {
                try {
                    snapShot = mDiskLruCache.get(key);
                    if (snapShot != null) {
                        inputStream = snapShot.getInputStream(0);
                        bitmap = decodeInputStream(inputStream, request, bitmapFactoryOptions);
                    }
                } catch (IOException e) {
                    Log.w(TAG, e);
                } finally {
                    IOUtils.closeQuietly(snapShot);
                    IOUtils.closeQuietly(inputStream);
                }
            }

            if (bitmap != null) {
                return mMemoryCache.putCached(getMemoryCacheKey(key, request), bitmap);
            }
        } finally {
            lock.unlock();
        }

        return null;// Bitmap is always null here
    }

    private BitmapDrawable getFromNetwork(String key, String source, ExtendedRequest request) {
        if (copyUrlToDiskLruCache(key, source)) {
            return getFromDisk(key, request);
        } else {
            return null;
        }
    }

    private BitmapFactory.Options decodeSampleSize(InputStream inputStream, ExtendedRequest request) {
        final BitmapFactory.Options bitmapFactoryOptions;
        if (request != null) {
            int height = request.getHeight();
            int width = request.getWidth();

            bitmapFactoryOptions = mBitmapOptionsFactory.newOptionsFromStream(inputStream, width, height);
        } else {
            bitmapFactoryOptions = new BitmapFactory.Options();
        }
        return setRequestOptions(bitmapFactoryOptions, request);
    }

    private Bitmap decodeInputStream(InputStream inputStream, ExtendedRequest request, BitmapFactory.Options bitmapFactoryOptions) {
        try {
            Bitmap bitmap;
            synchronized (DECODE_LOCK) {
                bitmap = BitmapFactory.decodeStream(new FlushedInputStream(inputStream), null, bitmapFactoryOptions);
            }
            if (request != null) {
                bitmap = request.onPreProcess(bitmap);
            }
            return bitmap;
        } catch (Throwable t) {
            if (mDebugging) {
                Log.w(TAG, t);
            }
        }
        return null;
    }

    private boolean copyUrlToDiskLruCache(String key, String source) {
        ReentrantLock lock = getLock(key);
        DiskLruCache.Editor editor = null;
        InputStream inputStream = null;
        OutputStream outputStream = null;
        try {
            lock.lock();

            /*
             * We block here because Editor.edit will return null if another
             * edit is in progress
             */
            while (editor == null) {
                editor = mDiskLruCache.edit(key);
                Thread.sleep(50);
            }

            URLConnection connection = mURLConnectionClient.open(new URL(source));
            connection.setConnectTimeout(5000);
            connection.setReadTimeout(10000);

            inputStream = connection.getInputStream();
            outputStream = editor.newOutputStream(0);

            IOUtils.copy(inputStream, outputStream);

            editor.commit();
            return true;
        } catch (IOException e) {
            if (mDebugging) {
                Log.w(TAG, e);
            }
        } catch (InterruptedException e) {
            if (mDebugging) {
                Log.d(TAG, "Thread was interrupted");
            }
        } finally {
            IOUtils.closeQuietly(inputStream);
            IOUtils.closeQuietly(outputStream);
            if (editor != null) {
                editor.abortUnlessCommitted();
            }
            lock.unlock();
        }
        return false;
    }

    private boolean verifySourceOverTime(String source, Request request) {
        boolean result = false;
        if (source != null && request != null) {
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                if (mDebugging) {
                    Log.d(TAG, "Thread was interrupted");
                }
            } finally {
                if (source.equals(request.getSource())) {
                    result = true;
                }
            }
        }
        return result;
    }

    private String getKey(String source) {
        if (source == null) {
            return null;
        } else {
            return Hashing.hashString(source);
        }
    }

    private BitmapFactory.Options setRequestOptions(BitmapFactory.Options options, ExtendedRequest request) {
        options.inPurgeable = true;
        options.inInputShareable = true;
        options.inPreferredConfig = request.getPreferredConfig();
        return options;
    }

    private static ExecutorService newLowPriorityCachedFixedThreadPool(int maximumPoolSize) {
        int corePoolSize = 0;
        long keepAliveTime = 60L;
        TimeUnit unit = TimeUnit.SECONDS;
        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<Runnable>();
        ThreadFactory factory = new LowPriorityThreadFactory();
        RejectedExecutionHandler handler = new ThreadPoolExecutor.CallerRunsPolicy();

        return new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, factory, handler);
    }

    public static enum Source {
        MEMORY,
        DISK,
        NETWORK
    }

    @SuppressWarnings("UnusedDeclaration")
    public static class Builder {

        private final Context mContext;

        private MemoryCache mMemoryCache;
        private BitmapOptionsFactory mBitmapOptionsFactory;
        private File mDiskCacheDirectory;
        private URLConnectionClient mURLConnectionClient;
        private boolean mDebugging;
        private int mMaxDiskCacheByteSize = -1;

        public Builder(Context context) {
            if (context == null) {
                throw new IllegalArgumentException("Context must not be null.");
            }
            mContext = context;
        }

        public void setURLConnectionClient(URLConnectionClient client) {
            if (client == null) {
                throw new IllegalArgumentException("URLConnectionClient must not be null.");
            }
            mURLConnectionClient = client;
        }

        public void setMemoryCache(MemoryCache cache) {
            if (cache == null) {
                throw new IllegalArgumentException("MemoryCache must not be null.");
            }
            mMemoryCache = cache;
        }

        public void setBitmapOptionsFactory(BitmapOptionsFactory factory) {
            if (factory == null) {
                throw new IllegalArgumentException("BitmapOptionsFactory must not be null.");
            }
            mBitmapOptionsFactory = factory;
        }

        public void setDiskCacheDirectory(File directory) {
            if (directory == null) {
                throw new IllegalArgumentException("File must not be null.");
            }
            mDiskCacheDirectory = directory;
        }

        public void setDiskCacheMaxByteSize(int maxDiskCacheByteSize) {
            if (maxDiskCacheByteSize < 0) {
                throw new IllegalArgumentException("Max disk cache byte size must be >= 0.");
            }
            mMaxDiskCacheByteSize = maxDiskCacheByteSize;
        }

        public void setDebugging(boolean value) {
            mDebugging = value;
        }

        public Prime build() {

            if (mMemoryCache == null) {
                DisplayMetrics displaymetrics = mContext.getResources().getDisplayMetrics();
                int maxMemoryByteSize = (displaymetrics.heightPixels * displaymetrics.widthPixels) * 3;
                mMemoryCache = new BitmapMemoryLruCache(mContext.getResources(), maxMemoryByteSize);
            }

            if (mBitmapOptionsFactory == null) {
                mBitmapOptionsFactory = new DefaultBitmapOptionsFactory();
            }

            if (mDiskCacheDirectory == null) {
                mDiskCacheDirectory = mContext.getCacheDir();
            }

            if (mURLConnectionClient == null) {
                mURLConnectionClient = new DefaultConnectionClient();
            }

            if (mMaxDiskCacheByteSize == -1) {
                mMaxDiskCacheByteSize = 10 * 1024 * 1024;
            }

            return new Prime(mMemoryCache, mBitmapOptionsFactory, mDiskCacheDirectory, mURLConnectionClient, mDebugging, mMaxDiskCacheByteSize);
        }
    }
}